import 'package:firebase_core_dart/firebase_core_dart.dart';

/// A DataSnapshot contains data from a Firebase Database location.
/// Any time you read Firebase data, you receive the data as a DataSnapshot.
class DataSnapshot {
  DataSnapshot(
    this.key,
    this.ref,
    this.value,
    this.priority,
    this.exists,
    this.children,
  );

  /// The key of the location that generated this DataSnapshot or null if at
  /// database root.
  final String? key;

  /// The Reference for the location that generated this DataSnapshot.
  DatabaseReference ref;

  /// Returns the contents of this data snapshot as native types.
  Object? value;

  /// Gets the priority value of the data in this [DataSnapshot] or null if no
  /// priority set.
  Object? priority;

  /// Ascertains whether the value exists at the Firebase Database location.
  bool exists;

  /// Returns true if the specified child path has (non-null) data.
  bool hasChild(String path) {
    final pathElems = path.split('/');
    var v = value;
    if (v is! Map) {
      return false;
    }
    for (final segment in pathElems) {
      if (segment.isEmpty) {
        continue;
      } else {
        if (v is! Map) {
          return false;
        }
        v = v[segment];
      }
    }
    if (v != null) {
      return true;
    }
    return false;
  }

  /// Gets another [DataSnapshot] for the location at the specified relative path.
  /// The relative path can either be a simple child name (for example, "ada")
  /// or a deeper, slash-separated path (for example, "ada/name/first").
  /// If the child location has no data, an empty DataSnapshot (that is, a
  /// DataSnapshot whose [value] is null) is returned.
  DataSnapshot child(String path) {
    final pathElems = path.split('/');
    var v = value;
    if (v is! Map) {
      return DataSnapshot(null);
    }
    for (final segment in pathElems) {
      if (segment.isEmpty) {
        continue;
      } else {
        if (v is! Map) {
          return DataSnapshot(null);
        }
        v = v[segment];
      }
    }
    if (v != null) {
      return DataSnapshot(v);
    }
    return DataSnapshot(null);
  }

  /// An iterator for snapshots of the child nodes in this snapshot.
  Iterable<DataSnapshot> children;
}

/// `DatabaseEvent` encapsulates a DataSnapshot and possibly also the key of its
/// previous sibling, which can be used to order the snapshots.
class DatabaseEvent {
  DatabaseEvent._(this.type, this.snapshot, this.previousChildKey);

  /// The type of event.
  DatabaseEventType type;

  /// The [DataSnapshot] for this event.
  DataSnapshot snapshot;

  /// A string containing the key of the previous sibling child by sort order,
  /// or null if it is the first child.
  String? previousChildKey;
}

/// DatabaseReference represents a particular location in your Firebase
/// Database and can be used for reading or writing data to that location.
///
/// This class is the starting point for all Firebase Database operations.
/// After you’ve obtained your first `DatabaseReference` via
/// `FirebaseDatabase.instance.ref()`, you can use it to read data
/// (ie. `onChildAdded`), write data (ie. `setValue`), and to create new
/// `DatabaseReference`s (ie. `child`).
class DatabaseReference extends Query {
  DatabaseReference(this.root, this.parent, this.key) : super('parent/$key');

  /// Gets a DatabaseReference for the location at the specified relative
  /// path. The relative path can either be a simple child key (e.g. ‘fred’) or
  /// a deeper slash-separated path (e.g. ‘fred/name/first’).
  DatabaseReference child(String path) {}

  /// Gets a DatabaseReference for the parent location. If this instance
  /// refers to the root of your Firebase Database, it has no parent, and
  /// therefore parent() will return null.
  DatabaseReference? parent;

  /// Gets a [DatabaseReference] for the root location.
  DatabaseReference root;

  /// Gets the last token in a Firebase Database location (e.g. ‘fred’ in
  /// https://SampleChat.firebaseIO-demo.com/users/fred)
  String? key;

  /// Generates a new child location using a unique key and returns a
  /// DatabaseReference to it. This is useful when the children of a Firebase
  /// Database location represent a list of items.
  ///
  /// The unique key generated by childByAutoId: is prefixed with a
  /// client-generated timestamp so that the resulting list will be
  /// chronologically-sorted.
  DatabaseReference push() {}

  /// Write a `value` to the location.
  ///
  /// This will overwrite any data at this location and all child locations.
  ///
  /// Data types that are allowed are String, boolean, int, double, Map, List.
  ///
  /// The effect of the write will be visible immediately and the corresponding
  /// events will be triggered. Synchronization of the data to the Firebase
  /// Database servers will also be started.
  ///
  /// Passing null for the new value means all data at this location or any
  /// child location will be deleted.
  Future<void> set(Object? value) {}

  /// Write a `value` to the location with the specified `priority` if applicable.
  ///
  /// This will overwrite any data at this location and all child locations.
  ///
  /// Data types that are allowed are String, boolean, int, double, Map, List.
  ///
  /// The effect of the write will be visible immediately and the corresponding
  /// events will be triggered. Synchronization of the data to the Firebase
  /// Database servers will also be started.
  ///
  /// Passing null for the new value means all data at this location or any
  /// child location will be deleted.
  /// Note: [priority] can be a [String], [double] or [null] value.
  Future<void> setWithPriority(Object? value, Object? priority) {
    assert(priority == null || priority is String || priority is num);
  }

  /// Writes multiple values to the Database at once.
  ///
  /// The values argument contains multiple property-value pairs that will be
  /// written to the Database together. Each child property can either be a
  /// simple property (for example, "name") or a relative path (for example,
  /// "name/first") from the current location to the data to update.
  ///
  /// As opposed to the [set] method, [update] can be use to selectively update
  /// only the referenced properties at the current location
  /// (instead of replacing all the child properties at the current location).
  ///
  /// The effect of the write will be visible immediately, and the corresponding
  /// events ('value', 'child_added', etc.) will be triggered. Synchronization
  /// of the data to the Firebase servers will also be started, and the
  /// returned [Future] will resolve when complete.
  ///
  /// A single [update] will generate a single "value" event at the location
  /// where the [update] was performed, regardless of how many children were modified.
  ///
  /// Note that modifying data with [update] will cancel any pending transactions
  /// at that location, so extreme care should be taken if mixing [update] and
  /// [runTransaction] to modify the same data.
  ///
  /// Passing null to a [Map] value in [update] will remove the remove the value
  /// at the specified location.
  Future<void> update(Map<String, Object?> value) {}

  /// Sets a priority for the data at this Firebase Database location.
  ///
  /// Priorities can be used to provide a custom ordering for the children at a
  /// location (if no priorities are specified, the children are ordered by
  /// key).
  ///
  /// You cannot set a priority on an empty location. For this reason
  /// set() should be used when setting initial data with a specific priority
  /// and setPriority() should be used when updating the priority of existing
  /// data.
  ///
  /// Children are sorted based on this priority using the following rules:
  ///
  /// Children with no priority come first. Children with a number as their
  /// priority come next. They are sorted numerically by priority (small to
  /// large). Children with a string as their priority come last. They are
  /// sorted lexicographically by priority. Whenever two children have the same
  /// priority (including no priority), they are sorted by key. Numeric keys
  /// come first (sorted numerically), followed by the remaining keys (sorted
  /// lexicographically).
  ///
  /// Note that priorities are parsed and ordered as IEEE 754 double-precision
  /// floating-point numbers. Keys are always stored as strings and are treated
  /// as numbers only when they can be parsed as a 32-bit integer.
  ///
  /// Note: [priority] can be a [String], [double] or [null] value.
  Future<void> setPriority(Object? priority) async {
    assert(priority == null || priority is String || priority is num);
  }

  /// Remove the data at this Firebase Database location. Any data at child
  /// locations will also be deleted.
  ///
  /// The effect of the delete will be visible immediately and the corresponding
  /// events will be triggered. Synchronization of the delete to the Firebase
  /// Database servers will also be started.
  ///
  /// remove() is equivalent to calling set(null)
  Future<void> remove() => set(null);

  /// Performs an optimistic-concurrency transactional update to the data at
  /// this Firebase Database location.
  Future<TransactionResult> runTransaction(
    TransactionHandler transactionHandler, {
    bool applyLocally = true,
  }) async {
    return TransactionResult();
  }

  /// Returns an [OnDisconnect] instance.
  OnDisconnect onDisconnect() {
    return OnDisconnect();
  }
}

/// The entry point for accessing a Firebase Database. You can get an instance
/// by calling `FirebaseDatabase.instance` or `FirebaseDatabase.instanceFor()`.
class FirebaseDatabase {
  /// Returns an instance of [FirebaseDatabase] with the given [FirebaseApp] and/or
  /// [databaseURL).
  @Deprecated(
    'Accessing FirebaseDatabase via the constructor is now deprecated. Use `.instanceFor` instead.',
  )
  factory FirebaseDatabase({FirebaseApp? app, String? databaseURL}) {
    return FirebaseDatabase.instanceFor(
      app: app ?? Firebase.app(),
      databaseURL: databaseURL,
    );
  }

  FirebaseDatabase._({required this.app, this.databaseURL}) {
    if (databaseURL != null && databaseURL!.endsWith('/')) {
      databaseURL = databaseURL!.substring(0, databaseURL!.length - 1);
    }
  }

  /// The [FirebaseApp] for this current [FirebaseDatabase] instance.
  FirebaseApp app;

  /// A custom Database URL for this instance.
  String? databaseURL;

  static final Map<String, FirebaseDatabase> _cachedInstances = {};

  /// Returns an instance using the default [FirebaseApp].
  static FirebaseDatabase get instance {
    return FirebaseDatabase.instanceFor(
      app: Firebase.app(),
    );
  }

  /// Returns an instance using a specified [FirebaseApp].
  static FirebaseDatabase instanceFor({
    required FirebaseApp app,
    String? databaseURL,
  }) {
    final cacheKey = '${app.name}|$databaseURL';
    if (_cachedInstances.containsKey(cacheKey)) {
      return _cachedInstances[cacheKey]!;
    }

    final newInstance = FirebaseDatabase._(app: app, databaseURL: databaseURL);
    _cachedInstances[cacheKey] = newInstance;

    return newInstance;
  }

  /// Changes this instance to point to a FirebaseDatabase emulator running locally.
  ///
  /// Set the [host] of the local emulator, such as "localhost"
  /// Set the [port] of the local emulator, such as "9000" (default is 9000)
  ///
  /// Note: Must be called immediately, prior to accessing FirebaseFirestore methods.
  /// Do not use with production credentials as emulator traffic is not encrypted.
  void useDatabaseEmulator(String host, int port) {}

  /// Returns a [DatabaseReference] accessing the root of the database.
  @Deprecated('Deprecated in favor of calling `ref()`.')
  DatabaseReference reference() => ref();

  /// Returns a [DatabaseReference] representing the location in the Database
  /// corresponding to the provided path.
  /// If no path is provided, the Reference will point to the root of the Database.
  DatabaseReference ref([String? path]) {
    return DatabaseReference();
  }

  /// Returns a [DatabaseReference] representing the location in the Database
  /// corresponding to the provided Firebase URL.
  DatabaseReference refFromURL(String url) {
    if (!url.startsWith('https://')) {
      throw ArgumentError.value(url, 'must be a valid URL', 'url');
    }

    final uri = Uri.parse(url);
    final currentDatabaseUrl = databaseURL ?? app.options.databaseURL;
    if (currentDatabaseUrl != null) {
      if (uri.origin != currentDatabaseUrl) {
        throw ArgumentError.value(
          url,
          'must equal the current FirebaseDatabase instance databaseURL',
          'url',
        );
      }
    }

    if (uri.pathSegments.isNotEmpty) {
      return DatabaseReference();
    }
    return DatabaseReference();
  }

  /// Attempts to sets the database persistence to [enabled].
  ///
  /// This property must be set before calling methods on database references
  /// and only needs to be called once per application.
  ///
  /// The Firebase Database client will cache synchronized data and keep track
  /// of all writes you’ve initiated while your application is running. It
  /// seamlessly handles intermittent network connections and re-sends write
  /// operations when the network connection is restored.
  ///
  /// However by default your write operations and cached data are only stored
  /// in-memory and will be lost when your app restarts. By setting [enabled]
  /// to `true`, the data will be persisted to on-device (disk) storage and will
  /// thus be available again when the app is restarted (even when there is no
  /// network connectivity at that time).
  void setPersistenceEnabled(bool enabled) {}

  /// Attempts to set the size of the persistence cache.
  ///
  /// By default the Firebase Database client will use up to 10MB of disk space
  /// to cache data. If the cache grows beyond this size, the client will start
  /// removing data that hasn't been recently used. If you find that your
  /// application caches too little or too much data, call this method to change
  /// the cache size.
  ///
  /// This property must be set before calling methods on database references
  /// and only needs to be called once per application. The returned [Future]
  /// will complete with `true` if the operation was successful or `false` if
  /// the value could not be set (because database references have already been
  /// created).
  ///
  /// Note that the specified cache size is only an approximation and the size
  /// on disk may temporarily exceed it at times. Cache sizes smaller than 1 MB
  /// or greater than 100 MB are not supported.
  void setPersistenceCacheSizeBytes(int cacheSize) {}

  /// Enables verbose diagnostic logging for debugging your application.
  /// This must be called before any other usage of FirebaseDatabase instance.
  /// By default, diagnostic logging is disabled.
  void setLoggingEnabled(bool enabled) {}

  /// Resumes our connection to the Firebase Database backend after a previous
  /// [goOffline] call.
  Future<void> goOnline() {}

  /// Shuts down our connection to the Firebase Database backend until
  /// [goOnline] is called.
  Future<void> goOffline() {}

  /// The Firebase Database client automatically queues writes and sends them to
  /// the server at the earliest opportunity, depending on network connectivity.
  /// In some cases (e.g. offline usage) there may be a large number of writes
  /// waiting to be sent. Calling this method will purge all outstanding writes
  /// so they are abandoned.
  ///
  /// All writes will be purged, including transactions and onDisconnect writes.
  /// The writes will be rolled back locally, perhaps triggering events for
  /// affected event listeners, and the client will not (re-)send them to the
  /// Firebase Database backend.
  Future<void> purgeOutstandingWrites() {}
}

/// The onDisconnect class allows you to write or clear data when your client
/// disconnects from the Database server. These updates occur whether your
/// client disconnects cleanly or not, so you can rely on them to clean up data
/// even if a connection is dropped or a client crashes.
///
/// The onDisconnect class is most commonly used to manage presence in
/// applications where it is useful to detect how many clients are connected
/// and when other clients disconnect.
///
/// To avoid problems when a connection is dropped before the requests can be
/// transferred to the Database server, these functions should be called before
/// writing any data.
///
/// Note that onDisconnect operations are only triggered once. If you want an
/// operation to occur each time a disconnect occurs, you'll need to
/// re-establish the onDisconnect operations each time you reconnect.
class OnDisconnect {
  OnDisconnect();

  /// Ensures the data at this location is set to the specified value when the
  /// client is disconnected (due to closing the browser, navigating to a new
  /// page, or network issues).
  Future<void> set(Object? value) {}

  /// Ensures the data at this location is set with a priority to the specified
  /// value when the client is disconnected (due to closing the browser,
  /// navigating to a new page, or network issues).
  Future<void> setWithPriority(Object? value, Object? priority) {}

  /// Ensures the data at this location is deleted when the client is
  /// disconnected (due to closing the browser, navigating to a new page,
  /// or network issues).
  Future<void> remove() => set(null);

  /// Cancels all previously queued onDisconnect() set or update events for
  /// this location and all children.
  Future<void> cancel() {}

  /// Writes multiple values at this location when the client is disconnected
  /// (due to closing the browser, navigating to a new page, or network issues).
  Future<void> update(Map<String, Object?> value) {}
}

/// Represents a query over the data at a particular location.
class Query {
  Query(this.path, [QueryModifiers? modifiers])
      : _modifiers = modifiers ?? QueryModifiers([]);

  final QueryModifiers _modifiers;

  /// Obtains a [DatabaseReference] corresponding to this query's location.
  DatabaseReference get ref => DatabaseReference.fromPath(path);

  /// Gets the most up-to-date result for this query.
  Future<DataSnapshot> get() async {}

  /// Slash-delimited path representing the database location of this query.
  String path;

  /// Listens for exactly one event of the specified event type, and then stops listening.
  /// Defaults to [DatabaseEventType.value] if no [eventType] provided.
  Future<DatabaseEvent> once([
    DatabaseEventType eventType = DatabaseEventType.value,
  ]) async {
    switch (eventType) {
      case DatabaseEventType.childAdded:
        return DatabaseEvent._(
          await _queryDelegate.onChildAdded(_modifiers).first,
        );
      case DatabaseEventType.childRemoved:
        return DatabaseEvent._(
          await _queryDelegate.onChildRemoved(_modifiers).first,
        );
      case DatabaseEventType.childChanged:
        return DatabaseEvent._(
          await _queryDelegate.onChildChanged(_modifiers).first,
        );
      case DatabaseEventType.childMoved:
        return DatabaseEvent._(
          await _queryDelegate.onChildMoved(_modifiers).first,
        );
      case DatabaseEventType.value:
        return DatabaseEvent._(await _queryDelegate.onValue(_modifiers).first);
    }
  }

  /// Fires when children are added.
  Stream<DatabaseEvent> get onChildAdded => _queryDelegate
      .onChildAdded(_modifiers)
      .map((item) => DatabaseEvent._(item));

  /// Fires when children are removed. `previousChildKey` is null.
  Stream<DatabaseEvent> get onChildRemoved => _queryDelegate
      .onChildRemoved(_modifiers)
      .map((item) => DatabaseEvent._(item));

  /// Fires when children are changed.
  Stream<DatabaseEvent> get onChildChanged => _queryDelegate
      .onChildChanged(_modifiers)
      .map((item) => DatabaseEvent._(item));

  /// Fires when children are moved.
  Stream<DatabaseEvent> get onChildMoved => _queryDelegate
      .onChildMoved(_modifiers)
      .map((item) => DatabaseEvent._(item));

  /// Fires when the data at this location is updated. `previousChildKey` is null.
  Stream<DatabaseEvent> get onValue =>
      _queryDelegate.onValue(_modifiers).map((item) => DatabaseEvent._(item));

  /// Create a query constrained to only return child nodes with a value greater
  /// than or equal to the given value, using the given orderBy directive or
  /// priority as default, and optionally only child nodes with a key greater
  /// than or equal to the given key.
  Query startAt(Object? value, {String? key}) {
    return Query._(
      _queryDelegate,
      _modifiers.start(StartCursorModifier.startAt(value, key)),
    );
  }

  /// Creates a [Query] with the specified starting point (exclusive).
  /// Using [startAt], [startAfter], [endBefore], [endAt] and [equalTo]
  /// allows you to choose arbitrary starting and ending points for your
  /// queries.
  ///
  /// The starting point is exclusive.
  ///
  /// If only a value is provided, children with a value greater than
  /// the specified value will be included in the query.
  /// If a key is specified, then children must have a value greater than
  /// or equal to the specified value and a a key name greater than
  /// the specified key.
  Query startAfter(Object? value, {String? key}) {
    return Query._(
      _queryDelegate,
      _modifiers.start(StartCursorModifier.startAfter(value, key)),
    );
  }

  /// Create a query constrained to only return child nodes with a value less
  /// than or equal to the given value, using the given orderBy directive or
  /// priority as default, and optionally only child nodes with a key less
  /// than or equal to the given key.
  Query endAt(Object? value, {String? key}) {
    return Query._(
      _queryDelegate,
      _modifiers.end(EndCursorModifier.endAt(value, key)),
    );
  }

  /// Creates a [Query] with the specified ending point (exclusive)
  /// The ending point is exclusive. If only a value is provided,
  /// children with a value less than the specified value will be included in
  /// the query. If a key is specified, then children must have a value lesss
  /// than or equal to the specified value and a a key name less than the
  /// specified key.
  Query endBefore(Object? value, {String? key}) {
    return Query._(
      _queryDelegate,
      _modifiers.end(EndCursorModifier.endBefore(value, key)),
    );
  }

  /// Create a query constrained to only return child nodes with the given
  /// `value` (and `key`, if provided).
  ///
  /// If a key is provided, there is at most one such child as names are unique.
  Query equalTo(Object? value, {String? key}) {
    return Query._(
      _queryDelegate,
      _modifiers
          .start(StartCursorModifier.startAt(value, key))
          .end(EndCursorModifier.endAt(value, key)),
    );
  }

  /// Create a query with limit and anchor it to the start of the window.
  Query limitToFirst(int limit) {
    return Query._(
      _queryDelegate,
      _modifiers.limit(LimitModifier.limitToFirst(limit)),
    );
  }

  /// Create a query with limit and anchor it to the end of the window.
  Query limitToLast(int limit) {
    return Query._(
      _queryDelegate,
      _modifiers.limit(LimitModifier.limitToLast(limit)),
    );
  }

  /// Generate a view of the data sorted by values of a particular child path.
  ///
  /// Intended to be used in combination with [startAt], [endAt], or
  /// [equalTo].
  Query orderByChild(String path) {
    assert(
      path.isNotEmpty,
      'The key cannot be empty. Use `orderByValue` instead',
    );
    return Query._(
      _queryDelegate,
      _modifiers.order(OrderModifier.orderByChild(path)),
    );
  }

  /// Generate a view of the data sorted by key.
  ///
  /// Intended to be used in combination with [startAt], [endAt], or
  /// [equalTo].
  Query orderByKey() {
    return Query._(
      _queryDelegate,
      _modifiers.order(
        OrderModifier.orderByKey(),
      ),
    );
  }

  /// Generate a view of the data sorted by value.
  ///
  /// Intended to be used in combination with [startAt], [endAt], or
  /// [equalTo].
  Query orderByValue() {
    return Query._(
      _queryDelegate,
      _modifiers.order(
        OrderModifier.orderByValue(),
      ),
    );
  }

  /// Generate a view of the data sorted by priority.
  ///
  /// Intended to be used in combination with [startAt], [endAt], or
  /// [equalTo].
  Query orderByPriority() {
    return Query._(
      _queryDelegate,
      _modifiers.order(
        OrderModifier.orderByPriority(),
      ),
    );
  }

  /// By calling keepSynced(true) on a location, the data for that location will
  /// automatically be downloaded and kept in sync, even when no listeners are
  /// attached for that location. Additionally, while a location is kept synced,
  /// it will not be evicted from the persistent disk cache.
  Future<void> keepSynced(bool value) {
    return _queryDelegate.keepSynced(_modifiers, value);
  }
}

/// Instances of this class represent the outcome of a transaction.
class TransactionResult {
  TransactionResult._(this.committed, this.snapshot);

  /// The [committed] status associated to this transaction result.
  bool committed;

  /// The [DataSnapshot] associated to this transaction result.
  DataSnapshot snapshot;
}

/// The pending result of a [TransactionHandler].
class Transaction {
  Transaction._(this.aborted, this.value);

  /// The transaction was successful and should update the reference to the new
  /// [value] provided.
  Transaction.success(Object? value) : this._(false, value);

  /// The transaction should be aborted.
  Transaction.abort() : this._(true, null);

  /// Whether the transaction was aborted.
  final bool aborted;

  /// The new value that will be set if the transaction was not [aborted].
  final Object? value;
}

class ServerValue {
  static const Map<String, String> timestamp = <String, String>{
    '.sv': 'timestamp'
  };

  /// Returns a placeholder value that can be used to atomically increment the
  /// current database value by the provided delta.
  static Map<dynamic, dynamic> increment(int delta) {
    return <dynamic, dynamic>{
      '.sv': {'increment': delta}
    };
  }
}

/// Represents the available modifiers of a Query instance.
class QueryModifiers {
  /// Constructs a new [QueryModifiers] instance with a given modifier list.
  QueryModifiers(this._modifiers);

  final List<QueryModifier> _modifiers;

  LimitModifier? get _limit {
    final ofType = _modifiers.whereType<LimitModifier>();
    if (ofType.isEmpty) return null;
    return ofType.first;
  }

  OrderModifier? get _order {
    final ofType = _modifiers.whereType<OrderModifier>();
    if (ofType.isEmpty) return null;
    return ofType.first;
  }

  StartCursorModifier? get _start {
    final ofType = _modifiers.whereType<StartCursorModifier>();
    if (ofType.isEmpty) return null;
    return ofType.first;
  }

  EndCursorModifier? get _end {
    final ofType = _modifiers.whereType<EndCursorModifier>();
    if (ofType.isEmpty) return null;
    return ofType.first;
  }

  /// Transforms the instance into an ordered serializable list.
  List<Map<String, Object?>> toList() {
    return _modifiers.map((m) => m.toMap()).toList(growable: false);
  }

  /// Returns the current ordered modifiers list.
  Iterable<QueryModifier> toIterable() {
    return _modifiers;
  }

  /// Creates a start cursor modifier.
  QueryModifiers start(StartCursorModifier modifier) {
    assert(
      _start == null,
      'A starting point was already set (by another call to `startAt`, `startAfter`, or `equalTo`)',
    );
    _assertCursorValue(modifier.value);
    return _add(modifier).._validate();
  }

  /// Creates an end cursor modifier.
  QueryModifiers end(EndCursorModifier modifier) {
    assert(
      _end == null,
      'A ending point was already set (by another call to `endAt`, `endBefore` or `equalTo`)',
    );
    _assertCursorValue(modifier.value);
    return _add(modifier).._validate();
  }

  /// Creates an limitTo modifier.
  QueryModifiers limit(LimitModifier modifier) {
    assert(
      _limit == null,
      'A limit was already set (by another call to `limitToFirst` or `limitToLast`)',
    );
    assert(modifier.value >= 0);
    return _add(modifier).._validate();
  }

  /// Creates an orderBy modifier.
  QueryModifiers order(OrderModifier modifier) {
    assert(
      _order == null,
      'An order has already been set, you cannot combine multiple order by calls',
    );
    return _add(modifier).._validate();
  }

  /// Adds a modifier, validates and returns a new [QueryModifiers] instance.
  QueryModifiers _add(QueryModifier modifier) {
    return QueryModifiers([..._modifiers, modifier]);
  }

  /// Validates the current modifiers.
  void _validate() {
    if (_order?.name == 'orderByKey') {
      if (_start != null) {
        assert(
          _start!.key == null,
          'When ordering by key, you may only pass a value argument with no key to `startAt`, `endAt`, or `equalTo`',
        );
        assert(
          _start!.value is String,
          'When ordering by key, you may only pass a value argument as a String to `startAt`, `endAt`, or `equalTo`',
        );
      }

      if (_end != null) {
        assert(
          _end!.key == null,
          'When ordering by key, you may only pass a value argument with no key to `startAt`, `endAt`, or `equalTo`',
        );
        assert(
          _end!.value is String,
          'When ordering by key, you may only pass a value argument as a String to `startAt`, `endAt`, or `equalTo`',
        );
      }
    }

    if (_order?.name == 'orderByPriority') {
      if (_start != null) {
        _assertPriorityValue(_start!.value);
      }
      if (_end != null) {
        _assertPriorityValue(_end!.value);
      }
    }
  }

  /// Asserts a query modifier value is a valid type.
  void _assertCursorValue(Object? value) {
    assert(
      value is String || value is bool || value is num || value == null,
      'value must be a String, Boolean, Number or null.',
    );
  }

  /// Asserts a given value is a valid priority.
  void _assertPriorityValue(Object? value) {
    assert(
      value == null || value is String || value is num,
      'When ordering by priority, the first value of an order must be a valid priority value (null, String or Number)',
    );
  }
}

/// A single interface for all modifiers to implement.
abstract class QueryModifier {
  /// Constructs a new [QueryModifier] instance.
  QueryModifier(this.name);

  /// The modifier name, e.g. startAt, endBefore, limitToLast etc.
  final String name;

  /// Converts the modifier into a serializable map.
  Map<String, dynamic> toMap();
}

/// A modifier representing a limit query.
class LimitModifier implements QueryModifier {
  LimitModifier._(this.name, this.value);

  /// Creates a new `limitToFirst` modifier with a limit.
  LimitModifier.limitToFirst(int limit) : this._('limitToFirst', limit);

  /// Creates a new `limitToLast` modifier with a limit.
  LimitModifier.limitToLast(int limit) : this._('limitToLast', limit);

  /// The limit value applied to the query.
  final int value;

  @override
  final String name;

  @override
  Map<String, dynamic> toMap() {
    return <String, dynamic>{'type': 'limit', 'name': name, 'limit': value};
  }
}

/// A modifier representing a start cursor query.
class StartCursorModifier extends _CursorModifier {
  StartCursorModifier._(String name, Object? value, String? key)
      : super(name, value, key);

  /// Creates a new `startAt` modifier with an optional key.
  StartCursorModifier.startAt(Object? value, String? key)
      : this._('startAt', value, key);

  /// Creates a new `startAfter` modifier with an optional key.
  StartCursorModifier.startAfter(Object? value, String? key)
      : this._('startAfter', value, key);
}

/// A modifier representing a end cursor query.
class EndCursorModifier extends _CursorModifier {
  EndCursorModifier._(String name, Object? value, String? key)
      : super(name, value, key);

  /// Creates a new `endAt` modifier with an optional key.
  EndCursorModifier.endAt(Object? value, String? key)
      : this._('endAt', value, key);

  /// Creates a new `endBefore` modifier with an optional key.
  EndCursorModifier.endBefore(Object? value, String? key)
      : this._('endBefore', value, key);
}

/// Underlying cursor query modifier for start and end points.
class _CursorModifier implements QueryModifier {
  _CursorModifier(this.name, this.value, this.key);

  @override
  final String name;

  /// The value to identify what value the cursor should target.
  final Object? value;

  /// An optional key for the cursor query.
  final String? key;

  @override
  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'type': 'cursor',
      'name': name,
      if (value != null) 'value': value,
      if (key != null) 'key': key,
    };
  }
}

/// A modifier representing an order modifier.
class OrderModifier implements QueryModifier {
  OrderModifier._(this.name, this.path);

  /// Creates a new `orderByChild` modifier with path.
  OrderModifier.orderByChild(String path) : this._('orderByChild', path);

  /// Creates a new `orderByKey` modifier.
  OrderModifier.orderByKey() : this._('orderByKey', null);

  /// Creates a new `orderByValue` modifier.
  OrderModifier.orderByValue() : this._('orderByValue', null);

  /// Creates a new `orderByPriority` modifier.
  OrderModifier.orderByPriority() : this._('orderByPriority', null);

  @override
  final String name;

  /// A path value when ordering by a child path.
  final String? path;

  @override
  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'type': 'orderBy',
      'name': name,
      if (path != null) 'path': path,
    };
  }
}

/// Enum to define various types of database events
enum DatabaseEventType {
  /// Event for [onChildAdded] listener
  childAdded,

  /// Event for [onChildRemoved] listener
  childRemoved,

  /// Event for [onChildChanged] listener
  childChanged,

  /// Event for [onChildMoved] listener
  childMoved,

  /// Event for [onValue] listener
  value,
}

const _eventTypeFromStringMap = {
  'childAdded': DatabaseEventType.childAdded,
  'childRemoved': DatabaseEventType.childRemoved,
  'childChanged': DatabaseEventType.childChanged,
  'childMoved': DatabaseEventType.childMoved,
  'value': DatabaseEventType.value,
};

const _eventTypeToStringMap = {
  DatabaseEventType.childAdded: 'childAdded',
  DatabaseEventType.childRemoved: 'childRemoved',
  DatabaseEventType.childChanged: 'childChanged',
  DatabaseEventType.childMoved: 'childMoved',
  DatabaseEventType.value: 'value',
};

DatabaseEventType eventTypeFromString(String value) {
  if (!_eventTypeFromStringMap.containsKey(value)) {
    throw Exception('Unknown event type: $value');
  }
  return _eventTypeFromStringMap[value]!;
}

String eventTypeToString(DatabaseEventType value) {
  if (!_eventTypeToStringMap.containsKey(value)) {
    throw Exception('Unknown event type: $value');
  }
  return _eventTypeToStringMap[value]!;
}

/// Interface for [TransactionHandler]
typedef TransactionHandler = Transaction Function(Object? value);
